import flask
from flask import jsonify, render_template, request
import pandas as pd
import joblib
import random
import sqlite3
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import secure_filename
import os
from PIL import Image
import cv2
import numpy as np
import re
# using OpenCV's QRCodeDetector instead of pyzbar to avoid external DLL dependencies

app = flask.Flask(__name__)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
UPI_CSV = os.path.join(BASE_DIR, "upi_demo_dataset.csv")
QR_CSV = os.path.join(BASE_DIR, "qr_transaction_dataset.csv")
MODEL_PATH = os.path.join(BASE_DIR, "fraud_model.pkl")
QR_MODEL_PATH = os.path.join(BASE_DIR, "qr_model.pkl")
RECORDS_DIR = os.path.join(BASE_DIR, "records")
os.makedirs(RECORDS_DIR, exist_ok=True)

APPROVED_CSV = os.path.join(RECORDS_DIR, "approved_transactions.csv")
FRAUD_CSV = os.path.join(RECORDS_DIR, "fraudulent_transactions.csv")
REVIEW_CSV = os.path.join(RECORDS_DIR, "review_transactions.csv")
def safe_load_model(path):
    """Attempt to load a joblib model. Return None if unavailable or on error."""
    if not os.path.exists(path):
        print(f"Model file not found: {path}")
        return None
    try:
        return joblib.load(path)
    except Exception as e:
        print(f"Failed loading model {path}: {e}")
        return None


def safe_read_csv(path, default_columns=None):
    """Attempt to read a CSV and return a DataFrame. If missing or unreadable, return
    an empty DataFrame with default_columns (if provided).
    """
    if not os.path.exists(path):
        print(f"CSV not found: {path}")
        if default_columns:
            return pd.DataFrame(columns=default_columns)
        return pd.DataFrame()
    try:
        return pd.read_csv(path)
    except Exception as e:
        print(f"Failed reading CSV {path}: {e}")
        if default_columns:
            return pd.DataFrame(columns=default_columns)
        return pd.DataFrame()


# Load model and datasets safely so the app doesn't crash at import time
model = safe_load_model(MODEL_PATH)
qr_model = safe_load_model(QR_MODEL_PATH)

# expected columns used throughout the app (best-effort)
expected_upi_cols = [
    "TransactionID",
    "Date",
    "Sender",
    "Receiver",
    "Amount",
    "Type",
    "Location",
    "Device",
    "FraudLabel",
]

df = safe_read_csv(UPI_CSV, default_columns=expected_upi_cols)
qr_dataset = safe_read_csv(QR_CSV)

if 'Date' in df.columns:
    df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
if 'Date' in qr_dataset.columns:
    qr_dataset['Date'] = pd.to_datetime(qr_dataset['Date'], errors='coerce')



# ==== HELPER FUNCTIONS ====
def ensure_csv(path, columns):
    if not os.path.exists(path):
        pd.DataFrame(columns=columns).to_csv(path, index=False)

def compute_feature_scores(txn, df):
    sender = txn.get('sender_id')
    amount = float(txn.get('amount', 0))
    device = txn.get('device_id')
    ts = txn.get('timestamp')
    location = txn.get('location')

    try:
        txn_dt = pd.to_datetime(ts)
    except Exception:
        txn_dt = None

    # --- Unknown Device ---
    sender_devices = df[df['Sender'] == sender]['DeviceID'].dropna().unique().tolist() if 'DeviceID' in df.columns else []
    if not sender_devices:
        unknown_device_score = 20 if device else 0
    elif device not in sender_devices:
        unknown_device_score = min(95, 40 + len(sender_devices) * 20)
    else:
        unknown_device_score = min(80, len(sender_devices) * 20)

    # --- Location Consistency ---
    sender_locations = df[df['Sender'] == sender]['Location'].dropna().unique().tolist() if 'Location' in df.columns else []
    if len(sender_locations) <= 1:
        location_consistency_score = 10
    elif location not in sender_locations:
        location_consistency_score = 90
    else:
        location_consistency_score = 40

    # --- Unusual Amount ---
    sender_amounts = df[df['Sender'] == sender]['Amount'].dropna().astype(float) if 'Amount' in df.columns else pd.Series(dtype=float)
    avg_amount = sender_amounts.mean() if not sender_amounts.empty else 0
    unusual_amount_score = 80 if amount >= 30000 or (avg_amount > 0 and amount > 5 * avg_amount) else 10

    # --- Time Anomaly ---
    time_anomaly_score = 0
    if txn_dt is not None:
        h = txn_dt.hour
        hours_hist = df[df['Sender'] == sender]['Date'].dt.hour if 'Date' in df.columns else pd.Series()
        if not hours_hist.empty:
            hour_freq = (hours_hist == h).sum()
            if len(hours_hist) > 0 and (hour_freq / len(hours_hist)) < 0.05:
                time_anomaly_score = 40
        if 12 <= h < 18 and amount >= 30000:
            time_anomaly_score = 85

    # --- Weighted Probability ---
    weights = {'unusual_amount': 0.35, 'unknown_device': 0.25, 'time_anomaly': 0.2, 'location_consistency': 0.2}
    fraud_prob = (
        unusual_amount_score * weights['unusual_amount'] +
        unknown_device_score * weights['unknown_device'] +
        time_anomaly_score * weights['time_anomaly'] +
        location_consistency_score * weights['location_consistency']
    ) / 100

    return {
        "unusual_amount": unusual_amount_score,
        "unknown_device": unknown_device_score,
        "time_anomaly": time_anomaly_score,
        "location_consistency": location_consistency_score,
        "fraud_probability": round(fraud_prob, 3),
        "avg_amount": float(avg_amount)
    }

# ==== ROUTES ====

@app.route("/evaluate", methods=["POST"])
def evaluate_transaction():
    data = request.get_json()
    if not data:
        return jsonify({"error": "No transaction data"}), 400

    features = compute_feature_scores(data, df)
    radar_data = {
        "labels": [
            "Unknown Device",
            "Location Consistency",
            "Unusual Amount",
            "Time Anomaly"
        ],
        "scores": [
            features["unknown_device"],
            features["location_consistency"],
            features["unusual_amount"],
            features["time_anomaly"]
        ]
    }

    return jsonify({
        "features": features,
        "radar": radar_data
    })

# Duplicate imports and path setup removed (already defined above)

@app.route('/decision', methods=['POST'])
def handle_decision():
    try:
        data = request.get_json()
        decision = data.get('decision')
        txn = data.get('txn')

        if not txn or not decision:
            return jsonify({"status": "error", "message": "Missing data"}), 400

        # map decision to correct filename
        decision_map = {
            'approve': 'approved_transactions.csv',
            'flag': 'fraudulent_transactions.csv',
            'review': 'review_transactions.csv'
        }

        filename = decision_map.get(decision.lower())
        if not filename:
            return jsonify({"status": "error", "message": "Invalid decision"}), 400

        file_path = os.path.join(RECORDS_DIR, filename)

        # convert transaction to DataFrame
        df_new = pd.DataFrame([txn])

        # append or create file
        if os.path.exists(file_path):
            df_old = pd.read_csv(file_path)
            df_combined = pd.concat([df_old, df_new], ignore_index=True)
        else:
            df_combined = df_new

        df_combined.to_csv(file_path, index=False)

        return jsonify({
            "status": "success",
            "message": f"Transaction saved to {filename}"
        }), 200

    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route("/")
def index():
    return render_template("index.html")

@app.route("/analysis")
def analysis_page():
    return render_template("analysis.html")

@app.route("/transaction")
def get_transaction():
    s = df.sample(1).iloc[0].to_dict()
    parties = f"{s['Sender']} → {s['Receiver']}"
    # If model not available, return sample transaction with no risk prediction
    if model is None:
        output = {
            "TransactionID": s.get("TransactionID"),
            "Date": s.get("Date"),
            "Amount": f"₹{s.get('Amount')}",
            "Type": s.get("Type"),
            "Parties": parties,
            "RiskScore": None,
            "Status": "Model unavailable",
            "Anomalies": "Unknown"
        }
        return jsonify(output)

    features = pd.get_dummies(pd.DataFrame([s]).drop(columns=["TransactionID", "Date", "Sender", "Receiver", "FraudLabel"]))
    for col in getattr(model, "feature_names_in_", []):
        if col not in features.columns:
            features[col] = 0
    features = features[getattr(model, "feature_names_in_", features.columns)]

    pred = model.predict(features)[0]
    prob = model.predict_proba(features)[0][1]
    risk_score = round(prob * 100, 2)
    status = "High Risk" if risk_score > 60 else "Low Risk"

    output = {
        "TransactionID": s["TransactionID"],
        "Date": s["Date"],
        "Amount": f"₹{s['Amount']}",
        "Type": s["Type"],
        "Parties": parties,
        "RiskScore": risk_score,
        "Status": status,
        "Anomalies": "Unusual transaction amount" if pred == 1 else "Completed"
    }

    return jsonify(output)

@app.route("/search_data")
def search_data():
    query = request.args.get("q", "").lower()
    filtered_df = df[
        df['TransactionID'].str.lower().str.contains(query) |
        df['Sender'].str.lower().str.contains(query) |
        df['Receiver'].str.lower().str.contains(query) |
        df['Type'].str.lower().str.contains(query)
    ]
    samples = filtered_df.to_dict(orient="records")
    output = []

    for s in samples:
        parties = f"{s['Sender']} → {s['Receiver']}"
        # If model missing, skip prediction and return neutral values
        if model is None:
            output.append({
                "TransactionID": s.get("TransactionID"),
                "Date": s.get("Date"),
                "Amount": f"₹{s.get('Amount')}",
                "Type": s.get("Type"),
                "Parties": parties,
                "RiskScore": None,
                "Status": "Model unavailable",
                "Anomalies": "Unknown"
            })
            continue

        features = pd.get_dummies(pd.DataFrame([s]).drop(columns=["TransactionID", "Date", "Sender", "Receiver", "FraudLabel"]))
        for col in getattr(model, "feature_names_in_", []):
            if col not in features.columns:
                features[col] = 0
        features = features[getattr(model, "feature_names_in_", features.columns)]

        pred = model.predict(features)[0]
        prob = model.predict_proba(features)[0][1]
        risk_score = round(prob * 100, 2)
        status = "High Risk" if risk_score > 60 else "Low Risk"

        output.append({
            "TransactionID": s["TransactionID"],
            "Date": s["Date"],
            "Amount": f"₹{s['Amount']}",
            "Type": s["Type"],
            "Parties": parties,
            "RiskScore": risk_score,
            "Status": status,
            "Anomalies": "Unusual transaction amount" if pred == 1 else "Completed"
        })
    return jsonify(output)

@app.route("/get_chart_data")
def get_chart_data():
    transaction_counts = df['Type'].value_counts().to_dict()
    return jsonify(transaction_counts)

@app.route("/analyze_qr", methods=["POST"])
def analyze_qr():
    data = request.get_json()
    payee_vpa = data.get("payee_vpa")
    merchant_code = data.get("merchant_code")

    result = qr_dataset[
        (qr_dataset["payee_vpa"] == payee_vpa) &
        (qr_dataset["merchant_code"] == merchant_code)
    ]

    if not result.empty:
        row = result.iloc[0]
        return jsonify({
            "payee_vpa": row["payee_vpa"],
            "merchant_code": row["merchant_code"],
            "location": row["location"],
            "device": row["device"],
            "transaction_type": row["transaction_type"]
        })
    else:
        return jsonify({"error": "No matching record found in dataset"})

@app.route("/analyze_transaction", methods=["POST"])
def analyze_transaction():
    tx_id = request.form.get("transaction_id", "").strip()
    if tx_id == "":
        return render_template("analysis.html", error="Please enter a Transaction ID")

    result = df[df["TransactionID"].astype(str) == tx_id]
    if result.empty:
        return render_template("analysis.html", error="Transaction not Found")

    row = result.iloc[0].to_dict()

    # Transaction Type Bar Chart
    transaction_counts = df['Type'].value_counts().to_dict()
    chart_labels = list(transaction_counts.keys())
    chart_data = list(transaction_counts.values())

    # Risk Pie Chart (FIXED)
    if 'FraudLabel' in df.columns:
        risk_counts = df['FraudLabel'].value_counts().to_dict()
    else:
        risk_counts = {"Unknown": 0}
    risk_labels = list(risk_counts.keys())
    risk_data = list(risk_counts.values())

    # Calculate RiskScore (if model available)
    if model is None:
        risk_score = None
    else:
        features = pd.get_dummies(pd.DataFrame([row]).drop(columns=["TransactionID", "Date", "Sender", "Receiver", "FraudLabel"], errors="ignore"))
        for col in getattr(model, "feature_names_in_", []):
            if col not in features.columns:
                features[col] = 0
        features = features[getattr(model, "feature_names_in_", features.columns)]
        prob = model.predict_proba(features)[0][1]
        risk_score = round(prob * 100, 2)

    transaction = {
        "TransactionID": row["TransactionID"],
        "Date": row["Date"],
        "Sender": row["Sender"],
        "Receiver": row["Receiver"],
        "Type": row["Type"],
        "Amount": row["Amount"],
        "Location": row["Location"],
        "Device": row["Device"],
        "RiskScore": risk_score,
        "FraudLabel": row["FraudLabel"]
    }

    # Behavior Profile for radar chart
    behavior_labels = ["Amount", "RiskScore", "FraudLabel", "LocationCount", "DailyCount"]
    max_amount = df['Amount'].max()
    amount_norm = transaction["Amount"] / max_amount
    fraud = transaction["FraudLabel"]
    location_count = len(df[df["Location"] == transaction["Location"]]) / df.shape[0]
    daily_count = len(df[df["Date"].dt.date == pd.to_datetime(transaction["Date"]).date()]) / df.shape[0]
    behavior_data = [round(amount_norm, 2), round(transaction["RiskScore"]/100, 2), fraud, round(location_count,2), round(daily_count,2)]

    return render_template(
        "analysis.html",
        transaction=transaction,
        chart_labels=chart_labels,
        chart_data=chart_data,
        risk_labels=risk_labels,
        risk_data=risk_data,
        behavior_labels=behavior_labels,
        behavior_data=behavior_data
    )
@app.route("/upload_qr", methods=["POST"])
def upload_qr():
    try:
        if "file" not in request.files:
            return jsonify({"error": "No file uploaded"}), 400

        file = request.files["file"]
        if not file.filename or file.filename == "":
            return jsonify({"error": "No file selected"}), 400

        upload_dir = os.path.join(BASE_DIR,"uploads")
        os.makedirs(upload_dir, exist_ok=True)

        filename = secure_filename(file.filename)
        path = os.path.join(upload_dir, filename)
        file.save(path)

        # ✅ READ QR IMAGE
        image = cv2.imread(path)
        if image is None:
            return jsonify({"error":"Invalid image"}),400

        detector = cv2.QRCodeDetector()
        qr_text,_,_ = detector.detectAndDecode(image)

        if not qr_text:
            return jsonify({"error":"QR not detected"}),400

        # ✅ FIXED REGEX
        match = re.search(r"pa=([^&]+)", qr_text)

        if not match:
            return jsonify({
                "qr_valid":True,
                "qr_data":qr_text,
                "fraud":"Unknown",
                "attributes":{}
            })

        upi = match.group(1).lower()

        print("UPI FOUND:",upi)

        record = qr_dataset[
            qr_dataset["Merchant_UPI"]
            .astype(str)
            .str.lower()
            ==
            upi
        ]

        if record.empty:
            return jsonify({
                "qr_valid":True,
                "qr_data":qr_text,
                "fraud":"Unknown",
                "attributes":{}
            })

        row = record.iloc[0]

        attributes = {
            "merchant": row["Merchant_Name"],
            "payee_vpa": row["Merchant_UPI"],
            "location": row["Merchant_City"],
            "category": row["Merchant_Category"],
            "customer": row["Customer_Name"],
            "phone": row["Customer_Phone"],
            "amount": row["Amount"],
            "payment_status": row["Payment_Status"],
            "date_time": row["Date_Time"]
        }

        return jsonify({
            "qr_valid":True,
            "qr_data":qr_text,
            "fraud": row["Fraudulent"],
            "attributes": attributes
        })

    except Exception as e:
        print("UPLOAD ERROR:", e)
        return jsonify({"error":str(e)}),500


if __name__ == "__main__":
    app.run(debug=True)
